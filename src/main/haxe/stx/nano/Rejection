package stx.nano;

typedef RefuseDef<E>            = Error<Decline<E>>;

@:using(stx.nano.Refuse.RefuseLift)
@:forward abstract Refuse<E>(RefuseDef<E>) from RefuseDef<E> to RefuseDef<E>{
  static public var _(default,never) = RefuseLift;
  public inline function new(self) this = self;
  static public inline function lift<E>(self:RefuseDef<E>):Refuse<E> return new Refuse(self);
  @:noUsing static public inline function make<E>(data:Option<Decline<E>>,lst:Option<Refuse<E>>,?pos:Pos):Refuse<E>{
    return lift(Error.make(data,lst.map(x -> x.prj()),pos));
  }
  @:noUsing static public function pure<E>(data:E):Refuse<E>{
    return make(Some(EXTERIOR(data)),None,__.here());
  }
  public function prj():RefuseDef<E> return this;
  private var self(get,never):Refuse<E>;
  private function get_self():Refuse<E> return lift(this);

  public function concat(that:Refuse<E>){
    return _.concat(this,that);
  }
  public var lst(get,never) : Option<Refuse<E>>;
  public function get_lst() : Option<Refuse<E>>{
    return this.lst.map(lift);
  }
  public function errate<EE>(fn:E->EE):Refuse<EE>{
    return _.errate(this,fn);
  }
  @:from static public function fromError<E>(self:Error<E>){
    return lift(self.errate(EXTERIOR));
  }
  @:from @:noUsing static public function fromDefect<T,E>(self:Defect<E>):Refuse<E>{
    return fromError(self.toError());
  }
  @:from @:noUsing static public function fromErrata<T,E>(self:Errata<E>):Refuse<E>{
    return fromError(self.toError());
  }
  public function iterator():Iterator<Null<Decline<E>>>{
    return this.iterator();
  }
}
class RefuseLift{
  static public inline function lift<E>(self:RefuseDef<E>):Refuse<E>{
    return Refuse.lift(self);
  }
  static public function concat<E>(self:RefuseDef<E>,that:Refuse<E>):Refuse<E>{
    return lift(self.concat(that.prj()));
  }
  static public function errate<E,EE>(self:RefuseDef<E>,fn:E->EE):Refuse<EE>{
    return lift(self.errate(x -> x.map(fn)));
  }
  static public function usher<E,Z>(self:RefuseDef<E>,fn:Option<E>->Z):Z{
    return switch(self.val){
      case Some(EXTERIOR(e))  : fn(Some(e));
      default               : fn(None);
    }
  }
  static public function fold<E,Z>(self:RefuseDef<E>,reject:E -> Z, explain : Digest -> Z, nothing : () -> Z) : Z {
    return switch(self.val){
      case Some(EXTERIOR(e)) : reject(e);
      case Some(INTERIOR(e)) : explain(e);
      case None            : nothing();
    }
  }
  //static public function elide<E>(self:RefuseDef<E>):Reje
// static public function reject<T,E>(self:RefuseDef<E>):Res<T,E>{
  
// }
  //static public function fold<E,Z>(self:RefuseDef<E>,fn:Fault->Option<E>)
}